{"version":3,"file":"slider/slider.min.js","mappings":"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","sources":["webpack://js-components/./src/components/slider/slider.ts"],"sourcesContent":["///resize observer for slider\r\nconst __JscSliderResizeObserver = new ResizeObserver( ( entries =>  {\r\n   entries.forEach( entry =>  {\r\n      const target = entry.target as JscSliderElement;\r\n      if( target.jscSlider instanceof JscSlider )  {\r\n         target.jscSlider._resize();\r\n      }\r\n   });\r\n}));\r\n\r\ninterface JscSliderElement extends HTMLElement  {\r\n   jscSlider?: JscSlider\r\n}\r\n\r\n///current pointer position\r\nlet __JscCurrentPointerPosition = 0;\r\n\r\ninterface JscSliderArgs {\r\n   container: string | HTMLElement,\r\n   slidesPerView?: number,\r\n   gap?: number,\r\n   prevEl?: string | HTMLElement,\r\n   nextEl?: string | HTMLElement,\r\n   breakPoints?: {},\r\n}\r\n\r\nfunction getPointerPosition( e: MouseEvent | TouchEvent )  {\r\n   return ( e instanceof MouseEvent ) ? e.clientX : e.touches[0].clientX;\r\n}\r\n\r\nclass JscSlider  {\r\n   ///core variables\r\n   container: JscSliderElement;\r\n   sliderWrapper: HTMLElement;\r\n   slides: NodeListOf<HTMLElement>;\r\n   sliderContainerWidth: number;\r\n\r\n   ///state variables\r\n   pointerStartingPosition = 0;\r\n   isClicked = false;\r\n   isPointerMoved = false;\r\n   currentIndex = 0;\r\n   slidesLength: number;\r\n   totalSlidesPerView: number;\r\n   firstDragTime = 0;\r\n   isFirstMove = false;\r\n   translate = 0;\r\n   breakPointWidths: number[] = [];\r\n   currentBreakPoint: number | null = null;\r\n   currentActiveWidth: number = 0;\r\n   _isTransitioning: boolean = false;\r\n   _transitionTimeoutId: ReturnType<typeof setTimeout>;\r\n   _tempIndex: number = 0;\r\n   _pointerPausePosition: number = 0;\r\n\r\n   ///can be change via args\r\n   slidesPerView = 1;\r\n   percentThreshold = 50;\r\n   timeThreshold = 300;\r\n   gap = 0;\r\n   breakPoints:any | {} = {};\r\n\r\n   constructor( args: JscSliderArgs )  {\r\n      ///check if container arg is string and valid DOM query\r\n      if( typeof args.container === 'string' )  {\r\n         args.container = document.querySelector( args.container ) as HTMLElement;\r\n      }\r\n\r\n      if( !( args.container instanceof HTMLElement ) )  return\r\n\r\n      this.container = args.container;\r\n      /** any expression after this */\r\n\r\n      /**** will improve this in more efficient way ****/\r\n      ///assign other arguments to global class variables\r\n\r\n      if( args.slidesPerView && args.slidesPerView > 0 )  {\r\n         this.slidesPerView = args.slidesPerView;\r\n      }\r\n\r\n      if( args.gap && args.gap > 0 )  this.gap = args.gap;\r\n\r\n      let prevBtn: string | HTMLElement | undefined = args.prevEl;\r\n      let nextBtn: string | HTMLElement | undefined = args.nextEl;\r\n\r\n      if( typeof prevBtn === 'string' )  {\r\n         prevBtn = this.container.querySelector( prevBtn ) ? this.container.querySelector( prevBtn ) as HTMLElement : document.querySelector( prevBtn ) as HTMLElement;\r\n      }\r\n\r\n      if( prevBtn instanceof HTMLElement )  {\r\n         prevBtn.setAttribute( 'aria-label', 'Previous slide' );\r\n         prevBtn.addEventListener( 'click', this.prevSlide.bind( this ) );\r\n      }\r\n\r\n      if( typeof nextBtn === 'string' )  {\r\n         nextBtn = this.container.querySelector( nextBtn ) ? this.container.querySelector( nextBtn ) as HTMLElement : document.querySelector( nextBtn ) as HTMLElement;\r\n      }\r\n\r\n      if( nextBtn instanceof HTMLElement )  {\r\n         nextBtn.setAttribute( 'aria-label', 'Next slide' );\r\n         nextBtn.addEventListener( 'click', this.nextSlide.bind( this ) );\r\n      }\r\n\r\n      if( typeof args.breakPoints === 'object' )  this.breakPoints = args.breakPoints;\r\n\r\n      /** ******* */\r\n\r\n      this._init();\r\n   }\r\n\r\n   _init()  {\r\n      ///save slider container width\r\n      this.sliderContainerWidth = this.container.getBoundingClientRect().width;\r\n      this.sliderWrapper = this.container.querySelector( '.jsc-slider-wrapper' ) as HTMLElement;\r\n      this.slides = this.container.querySelectorAll( '.slide' ) as NodeListOf<HTMLElement>;\r\n\r\n      if( !this.sliderWrapper || !this.slides )  return\r\n\r\n      ///this will be change when autoplay option going to introduce but for now it's hardcoded\r\n      this.sliderWrapper.setAttribute( 'aria-live', 'polite' );\r\n\r\n      ///https://developer.mozilla.org/en-US/docs/Glossary/Expando\r\n      ///add current instance to the container element for futher use likely for event bubbling\r\n      this.container.jscSlider = this;\r\n\r\n      /** initialize breakpoints */\r\n\r\n      ///save all the default values to breakpoint with value of width \"0\"\r\n      this.breakPoints[0] = {\r\n         slidesPerView: this.slidesPerView,\r\n         gap: this.gap\r\n      }\r\n\r\n      const breakPointWidths: number[] = [];\r\n      ///add all the breakpoints keys which has value of number to the breakPointWidths\r\n      Object.keys( this.breakPoints ).forEach( val => ( +val >= 0 ) ? breakPointWidths.push( +val ) : '' );\r\n      this.breakPointWidths = breakPointWidths.sort();\r\n\r\n      ///saving slides length\r\n      this.slidesLength = this.slides.length;\r\n\r\n      ///A11Y\r\n      this.slides.forEach( ( slide, i ) =>  {\r\n         slide.setAttribute( 'role', 'group' );\r\n         slide.setAttribute( 'aria-roledescription', 'slide' );\r\n         slide.setAttribute( 'aria-label', `${i + 1} / ${this.slidesLength}` );\r\n      });\r\n\r\n      ///apply all the responsive options to the slides\r\n      this._applyResponsiveness();\r\n\r\n      /** end initialization of breakpoints */\r\n\r\n      ///add all the slider events\r\n      this.container.addEventListener( 'pointerdown', this._pointerDown.bind( this ) );\r\n      this.container.addEventListener( 'pointerup', this._pointerLeave.bind( this ) );\r\n\r\n      ///add resize observer\r\n      __JscSliderResizeObserver.observe( this.container );\r\n\r\n      ///calculate slides dimensions\r\n      this._calcSlidesDimensions();\r\n   }\r\n\r\n   /** All Event functions */\r\n\r\n   _pointerDown( e: MouseEvent | TouchEvent )  {\r\n      const target = e.target as HTMLElement;\r\n\r\n      ///don't start moving slider if current target is not a slide, wrapper or container\r\n      if( target !== this.container && target.closest( '.slide' )?.closest( '.jsc-slider-container' ) !== this.container\r\n          && target.closest( '.jsc-slider-wrapper' ) !== this.sliderWrapper ) return\r\n\r\n      ///prevent default behavior in slide like image dragging effect inside slide\r\n      e.preventDefault();\r\n\r\n      this.pointerStartingPosition = getPointerPosition( e );\r\n      this.isClicked = true;\r\n\r\n      ///if slider is clicked during transitioning\r\n      if( this._isTransitioning )  {\r\n         clearTimeout( this._transitionTimeoutId );\r\n         this._isTransitioning = false;\r\n         this._tempIndex = this.currentIndex;\r\n         this.sliderWrapper.style.transitionDuration = '';\r\n         /**\r\n         * we need pointer pause position from the left\r\n         * so suppose if the current slide is first slide\r\n         * and when it's changing to next slide we will get\r\n         * the extact left position from \"getBoundingClientRect\" method\r\n         * but if the slide position is other than first we get the\r\n         * leftPosition + sliderWidth x currentSlidePosition = ?\r\n         * (actually it's not accurate but it's easy to understand this way)\r\n         * so we don't want \"sliderWidth x currentSlidePosition\" to be added to the\r\n         * leftPosition so we have reduce it according to the current slide\r\n         */\r\n         this._pointerPausePosition = ( ( this.currentIndex ) * ( this.sliderContainerWidth + this.gap ) ) + this.sliderWrapper.getBoundingClientRect().left;\r\n         this._pointerMove();\r\n      }\r\n   }\r\n\r\n   _pointerMove()  {\r\n      if( !this.isClicked ) return\r\n\r\n      if( !this.isFirstMove )  {\r\n         this.isFirstMove = true;\r\n         this.firstDragTime = new Date().getTime();\r\n      }\r\n\r\n      ///if positive then going to previous slide otherwise to the next slide\r\n      this.translate = ( __JscCurrentPointerPosition - this.pointerStartingPosition ) + ( this._pointerPausePosition );\r\n\r\n      ///slider width plus gap\r\n      const sliderWidthPlusGap = this.sliderContainerWidth + this.gap;\r\n\r\n      ///if current slide is last slide and going to next slide decrease the translate value\r\n      if( this.currentIndex >= ( this.totalSlidesPerView - 1 ) && this.translate < 0 )  {\r\n         this.sliderWrapper.style.transform = `translateX(${( this.translate / 2.5 ) - ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n         return\r\n      }\r\n\r\n      ///if current slide is first slide and going to previous slide decrease the translate value\r\n      if( this.currentIndex <= 0 && this.translate > 0 )  {\r\n         this.sliderWrapper.style.transform = `translateX(${( this.translate / 2.5 ) + ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n         return\r\n      }\r\n\r\n      ///move the slider\r\n      this.sliderWrapper.style.transform = `translateX(${this.translate - ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n   }\r\n\r\n   _pointerLeave()  {\r\n      ///if the slider was clicked without moving\r\n      ///then we don't have to do anything after that\r\n      if( !this.isFirstMove )  {\r\n         this.isClicked = false;\r\n         return\r\n      }\r\n\r\n      ///current percentage of drag\r\n      const currentDragPercent = ( 100 * Math.abs( this.translate ) ) / this.sliderContainerWidth;\r\n\r\n      ///if the drag distance is greater than percentThreshold of the container\r\n      ///or currentTime - dragStartTime is lower than the time threshold\r\n      ///increase or decrease the index based on the translate value\r\n      if( this.isClicked && ( ( new Date().getTime() - this.firstDragTime ) < this.timeThreshold || currentDragPercent > this.percentThreshold ) )  {\r\n\r\n         ///going to previous slide\r\n         if( this.translate > 0 && this.currentIndex > 0 )  this.prevSlide();\r\n\r\n         ///going to next slide\r\n         if( this.translate < 0 && this.currentIndex < ( this.totalSlidesPerView - 1 ) )  this.nextSlide();\r\n      }\r\n\r\n      this._reset();\r\n   }\r\n\r\n   _resize()  {\r\n      this._applyResponsiveness();\r\n      this.sliderContainerWidth = this.container.getBoundingClientRect().width;\r\n      this._reset();\r\n   }\r\n\r\n   /** End Event functions */\r\n\r\n   /** Controls Functions */\r\n\r\n   nextSlide()  {\r\n      if( this.currentIndex >= ( this.totalSlidesPerView - 1 ) ) return false;\r\n      this._tempIndex = this.currentIndex + 1;\r\n      clearTimeout( this._transitionTimeoutId );\r\n      this._transitionTimeoutId = setTimeout( () =>  {\r\n         this.currentIndex++;\r\n      }, 200 );\r\n\r\n      this._reset();\r\n      return true;\r\n   }\r\n\r\n   prevSlide()  {\r\n      if( this.currentIndex <= 0 ) return false;\r\n      this._tempIndex = this.currentIndex - 1;\r\n      clearTimeout( this._transitionTimeoutId );\r\n      this._transitionTimeoutId = setTimeout( () =>  {\r\n         this.currentIndex--;\r\n      }, 200 );\r\n\r\n      this._reset();\r\n      return true;\r\n   }\r\n\r\n   /** End Controls Functions */\r\n\r\n   /** Utilities Functions */\r\n\r\n   _applyResponsiveness()  {\r\n      const windowWidth = window.innerWidth;\r\n      const prevPerView = this.slidesPerView;\r\n\r\n      this.breakPointWidths.forEach( width =>  {\r\n         if( width > windowWidth )  return\r\n\r\n         ///slidesPerView\r\n         if( +( this.breakPoints[width].slidesPerView ) > 0 )  {\r\n            ///not trying to add values\r\n            this.slidesPerView = ( +this.breakPoints[width].slidesPerView );\r\n         }\r\n\r\n         ///gap\r\n         if( +( this.breakPoints[width].gap ) > 0 )  {\r\n            ///multiplying gap because i don't want \"1\" gap equal to \"1px\"\r\n            ///i want to double the gap\r\n            this.gap = ( +this.breakPoints[width].gap ) * 2;\r\n         }\r\n      });\r\n\r\n      ///adjust slide index based on current slidesPerView\r\n      if( this.currentIndex > 0 && prevPerView !== this.slidesPerView )  {\r\n         if( this.slidesPerView < prevPerView )  {\r\n            /**\r\n            * Suppose we have total of 6 slides and we want to find out the nearest index,\r\n            * so the current value of slidesPreView = 3 and the currentIndex = 1 (2nd slide)\r\n            * and we are changing slidesPreView to 1 so the currentIndex should be 3 (4th slide)\r\n            * prevSlidePreView x currentIndex = 3\r\n            */\r\n            this.currentIndex = ( prevPerView * this.currentIndex ) / this.slidesPerView;\r\n         } else if( this.slidesPerView > prevPerView )  {\r\n            /**\r\n            * prevView = 1, prevIndex = 4, currentView = 3\r\n            * prevIndex / currentView = 1.3333333\r\n            * round it to 1\r\n            */\r\n            this.currentIndex = Math.floor( this.currentIndex / this.slidesPerView );\r\n         }\r\n      }\r\n\r\n      this.totalSlidesPerView = this.slidesLength / this.slidesPerView;\r\n   }\r\n\r\n   _calcSlidesDimensions()  {\r\n      let slideWidth: number | null = null;\r\n\r\n      if( this.slidesPerView > 1 )  {\r\n         ///calculate slide width\r\n         slideWidth = ( this.sliderContainerWidth - ( this.gap * ( this.slidesPerView - 1 ) ) ) / this.slidesPerView;\r\n      }\r\n\r\n      this.slides.forEach( ( slide, i ) =>  {\r\n         if( slideWidth )  slide.style.width = slideWidth + 'px';\r\n\r\n         ///have to do this because the previous slidePerView slide width can be\r\n         ///different, so we have to remove the previous width it\r\n         if( slideWidth === null )  {\r\n            ///if slidePerView is 1 no need to add any width to slide\r\n            slide.style.width = '';\r\n         }\r\n\r\n         ///don't add left margin if this is first slide\r\n         if( i === 0 ) return\r\n\r\n         slide.style.marginLeft = this.gap + 'px';\r\n      });\r\n   }\r\n\r\n   _reset()  {\r\n      this.sliderWrapper.style.transitionDuration = \"300ms\";\r\n      ///restore slide position\r\n      ///using tempIndex for mimicking translate\r\n      this.sliderWrapper.style.transform = `translateX(${-( this._tempIndex * ( this.sliderContainerWidth + this.gap ) )}px)`;\r\n      this._isTransitioning = true;\r\n\r\n      setTimeout( () =>  {\r\n         this.sliderWrapper.style.transitionDuration = '';\r\n      }, 300 );\r\n\r\n      setTimeout( () =>  {\r\n         this._isTransitioning = false;\r\n      }, 200 );\r\n\r\n      ///recalculate slides width\r\n      this._calcSlidesDimensions();\r\n\r\n      ///reset state variables\r\n      this.isClicked = false;\r\n      this.isPointerMoved = false;\r\n      this.pointerStartingPosition = 0;\r\n      this.isFirstMove = false;\r\n      this.firstDragTime = 0;\r\n      this.translate = 0;\r\n      this._pointerPausePosition = 0;\r\n   }\r\n\r\n   /** End Utilities Functions */\r\n}\r\n\r\n\r\n///using IIFE so activeSlider variable can't be alter by anyone\r\n(() =>  {\r\n   ///current active slider\r\n   let activeSlider: null | JscSliderElement = null;\r\n\r\n   /** global events */\r\n\r\n   document.addEventListener( 'pointermove', ( e ) =>  {\r\n      const target = e.target;\r\n      __JscCurrentPointerPosition = getPointerPosition( e );\r\n\r\n      ///checking if the target is not a HTMLdocument because HTMLdocument don't have any nearset element\r\n      ///so there is no point of assigning new activeSlider, same goes to if the previous activeSlider\r\n      ///is equal to current target slider container\r\n      if( target instanceof HTMLElement )  {\r\n         const closestSlider = target.closest( '.jsc-slider-container' ) as JscSliderElement;\r\n         if( closestSlider !== activeSlider )  activeSlider = closestSlider;\r\n      }\r\n\r\n      ///if slider isClicked is false then don't move current activeSlider\r\n      if( !activeSlider || !( activeSlider.jscSlider instanceof JscSlider ) || !activeSlider.jscSlider.isClicked )  {\r\n         activeSlider = null\r\n         return\r\n      }\r\n\r\n      ///move slider\r\n      activeSlider.jscSlider._pointerMove();\r\n   });\r\n\r\n\r\n   function sliderLeave( e: Event, isBlurEvent: boolean = false )  {\r\n      const target = e.target;\r\n      if( activeSlider === null || !( activeSlider.jscSlider instanceof JscSlider ) ) return\r\n\r\n      /**\r\n      * if closest element is equal to current active slider don't need to reset the slider.\r\n      * Doing this because if the pointer pointing at the slider gap which is margin then this event\r\n      * will occur so which means slider is still moving so there is no need to rest the slider\r\n      * P.S don't need to worry about how slider will actually leave when the closest slider is activeSlider\r\n      * because it's directly implamented in the slider class itself\r\n      */\r\n      if( !isBlurEvent && !( target instanceof HTMLElement && ( target.closest( '.jsc-slider-container' ) !== activeSlider ) ) )  return\r\n\r\n      activeSlider.jscSlider._pointerLeave();\r\n      activeSlider = null;\r\n   }\r\n\r\n   ///pointer leave events\r\n   document.addEventListener( 'pointerup', sliderLeave );\r\n   document.addEventListener( 'pointerout', sliderLeave );\r\n\r\n   ///this event will happen when browser tab changes\r\n   document.addEventListener( 'visibilitychange', ( e ) =>  {\r\n      sliderLeave( e, true );\r\n   });\r\n\r\n   /** End global events */\r\n})();\r\n"],"names":["__JscSliderResizeObserver","ResizeObserver","entries","forEach","entry","target","jscSlider","JscSlider","_resize","__JscCurrentPointerPosition","getPointerPosition","e","MouseEvent","clientX","touches","constructor","args","pointerStartingPosition","isClicked","isPointerMoved","currentIndex","firstDragTime","isFirstMove","translate","breakPointWidths","currentBreakPoint","currentActiveWidth","_isTransitioning","_tempIndex","_pointerPausePosition","slidesPerView","percentThreshold","timeThreshold","gap","breakPoints","container","document","querySelector","HTMLElement","this","prevBtn","prevEl","nextBtn","nextEl","setAttribute","addEventListener","prevSlide","bind","nextSlide","_init","sliderContainerWidth","getBoundingClientRect","width","sliderWrapper","slides","querySelectorAll","Object","keys","val","push","sort","slidesLength","length","slide","i","_applyResponsiveness","_pointerDown","_pointerLeave","observe","_calcSlidesDimensions","closest","preventDefault","clearTimeout","_transitionTimeoutId","style","transitionDuration","left","_pointerMove","Date","getTime","sliderWidthPlusGap","totalSlidesPerView","transform","currentDragPercent","Math","abs","_reset","setTimeout","windowWidth","window","innerWidth","prevPerView","floor","slideWidth","marginLeft","activeSlider","sliderLeave","isBlurEvent","closestSlider"],"sourceRoot":""}