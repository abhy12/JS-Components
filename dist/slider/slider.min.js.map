{"version":3,"file":"./slider/slider.min.js","mappings":"aACA,IAAI,oBAAsB,CAAC,ECA3B,oBAAoB,EAAI,CAACA,EAASC,IAAe,CAChD,QAAQC,KAAOD,EACX,oBAAoB,EAAEA,EAAYC,CAAG,GAAK,CAAC,oBAAoB,EAAEF,EAASE,CAAG,GAC/E,OAAO,eAAeF,EAASE,EAAK,CAAE,WAAY,GAAM,IAAKD,EAAWC,CAAG,CAAE,CAAC,CAGjF,ECPA,oBAAoB,EAAI,CAACC,EAAKC,IAAU,OAAO,UAAU,eAAe,KAAKD,EAAKC,CAAI,E,2BCGtF,MAAM,0BAA4B,IAAI,eAAkBC,GAAY,CACjEA,EAAQ,QAASC,GAAU,CACxB,MAAMC,EAASD,EAAM,OACjBC,EAAO,qBAAqB,WAC7BA,EAAO,UAAU,QAAQ,CAE/B,CAAC,CACJ,CAAE,EAOF,IAAI,4BAA8B,EAWlC,SAAS,mBAAoBC,EAA8B,CACxD,OAASA,aAAa,WAAeA,EAAE,QAAUA,EAAE,QAAQ,CAAC,EAAE,OACjE,CAEe,MAAM,SAAW,CAgC7B,YAAaC,EAAuB,CAMjC,GA9BH,6BAA0B,EAC1B,eAAY,GACZ,oBAAiB,GACjB,kBAAe,EAGf,mBAAgB,EAChB,iBAAc,GACd,eAAY,EACZ,sBAA6B,CAAC,EAC9B,uBAAmC,KACnC,wBAA6B,EAC7B,sBAA4B,GAE5B,gBAAqB,EACrB,2BAAgC,EAGhC,mBAAgB,EAChB,sBAAmB,GACnB,mBAAgB,IAChB,SAAM,EACN,iBAAuB,CAAC,EAIjB,OAAOA,EAAK,WAAc,WAC3BA,EAAK,UAAY,SAAS,cAAeA,EAAK,SAAU,GAGvD,EAAGA,EAAK,qBAAqB,aAAiB,OAElD,KAAK,UAAYA,EAAK,UAMlBA,EAAK,eAAiBA,EAAK,cAAgB,IAC5C,KAAK,cAAgBA,EAAK,eAGzBA,EAAK,KAAOA,EAAK,IAAM,IAAK,KAAK,IAAMA,EAAK,KAEhD,IAAIC,EAA4CD,EAAK,OACjDE,EAA4CF,EAAK,OAEjD,OAAOC,GAAY,WACpBA,EAAU,KAAK,UAAU,cAAeA,CAAQ,EAAI,KAAK,UAAU,cAAeA,CAAQ,EAAmB,SAAS,cAAeA,CAAQ,GAG5IA,aAAmB,cACpBA,EAAQ,aAAc,aAAc,gBAAiB,EACrDA,EAAQ,iBAAkB,QAAS,KAAK,UAAU,KAAM,IAAK,CAAE,GAG9D,OAAOC,GAAY,WACpBA,EAAU,KAAK,UAAU,cAAeA,CAAQ,EAAI,KAAK,UAAU,cAAeA,CAAQ,EAAmB,SAAS,cAAeA,CAAQ,GAG5IA,aAAmB,cACpBA,EAAQ,aAAc,aAAc,YAAa,EACjDA,EAAQ,iBAAkB,QAAS,KAAK,UAAU,KAAM,IAAK,CAAE,GAG9D,OAAOF,EAAK,aAAgB,WAAY,KAAK,YAAcA,EAAK,aAIpE,KAAK,MAAM,CACd,CAEA,OAAS,CAMN,GAJA,KAAK,qBAAuB,KAAK,UAAU,sBAAsB,EAAE,MACnE,KAAK,cAAgB,KAAK,UAAU,cAAe,qBAAsB,EACzE,KAAK,OAAS,KAAK,UAAU,iBAAkB,QAAS,EAEpD,CAAC,KAAK,eAAiB,CAAC,KAAK,OAAU,OAG3C,KAAK,cAAc,aAAc,YAAa,QAAS,EAIvD,KAAK,UAAU,UAAY,KAK3B,KAAK,YAAY,CAAC,EAAI,CACnB,cAAe,KAAK,cACpB,IAAK,KAAK,GACb,EAEA,MAAMG,EAA6B,CAAC,EAEpC,OAAO,KAAM,KAAK,WAAY,EAAE,QAASC,GAAS,CAACA,GAAO,EAAMD,EAAiB,KAAM,CAACC,CAAI,EAAI,EAAG,EACnG,KAAK,iBAAmBD,EAAiB,KAAK,EAG9C,KAAK,aAAe,KAAK,OAAO,OAGhC,KAAK,OAAO,QAAS,CAAEE,EAAO,IAAQ,CACnCA,EAAM,aAAc,OAAQ,OAAQ,EACpCA,EAAM,aAAc,uBAAwB,OAAQ,EACpDA,EAAM,aAAc,aAAc,GAAG,EAAI,OAAO,KAAK,cAAe,CACvE,CAAC,EAGD,KAAK,qBAAqB,EAK1B,KAAK,UAAU,iBAAkB,cAAe,KAAK,aAAa,KAAM,IAAK,CAAE,EAC/E,KAAK,UAAU,iBAAkB,YAAa,KAAK,cAAc,KAAM,IAAK,CAAE,EAG9E,0BAA0B,QAAS,KAAK,SAAU,EAGlD,KAAK,sBAAsB,CAC9B,CAIA,aAAcN,EAA8B,CAxK/C,MAyKM,MAAMD,EAASC,EAAE,OAGbD,IAAW,KAAK,aAAa,EAAAA,EAAO,QAAS,QAAS,IAAzB,cAA4B,QAAS,4BAA8B,KAAK,WAClGA,EAAO,QAAS,qBAAsB,IAAM,KAAK,gBAGxDC,EAAE,eAAe,EAEjB,KAAK,wBAA0B,mBAAoBA,CAAE,EACrD,KAAK,UAAY,GAGb,KAAK,mBACN,aAAc,KAAK,oBAAqB,EACxC,KAAK,iBAAmB,GACxB,KAAK,WAAa,KAAK,aACvB,KAAK,cAAc,MAAM,mBAAqB,GAY9C,KAAK,sBAA4B,KAAK,cAAmB,KAAK,qBAAuB,KAAK,KAAU,KAAK,cAAc,sBAAsB,EAAE,KAC/I,KAAK,aAAa,GAExB,CAEA,cAAgB,CACb,GAAI,CAAC,KAAK,UAAY,OAEjB,KAAK,cACP,KAAK,YAAc,GACnB,KAAK,cAAgB,IAAI,KAAK,EAAE,QAAQ,GAI3C,KAAK,UAAc,4BAA8B,KAAK,wBAA8B,KAAK,sBAGzF,MAAMO,EAAqB,KAAK,qBAAuB,KAAK,IAG5D,GAAI,KAAK,cAAkB,KAAK,mBAAqB,GAAO,KAAK,UAAY,EAAK,CAC/E,KAAK,cAAc,MAAM,UAAY,cAAgB,KAAK,UAAY,IAAU,KAAK,aAAeA,OACpG,OAIH,GAAI,KAAK,cAAgB,GAAK,KAAK,UAAY,EAAK,CACjD,KAAK,cAAc,MAAM,UAAY,cAAgB,KAAK,UAAY,IAAU,KAAK,aAAeA,OACpG,OAIH,KAAK,cAAc,MAAM,UAAY,cAAc,KAAK,UAAc,KAAK,aAAeA,MAC7F,CAEA,eAAiB,CAGd,GAAI,CAAC,KAAK,YAAe,CACtB,KAAK,UAAY,GACjB,OAIH,MAAMC,EAAuB,IAAM,KAAK,IAAK,KAAK,SAAU,EAAM,KAAK,qBAKnE,KAAK,YAAiB,IAAI,KAAK,EAAE,QAAQ,EAAI,KAAK,cAAkB,KAAK,eAAiBA,EAAqB,KAAK,oBAGjH,KAAK,UAAY,GAAK,KAAK,aAAe,GAAK,KAAK,UAAU,EAG9D,KAAK,UAAY,GAAK,KAAK,aAAiB,KAAK,mBAAqB,GAAO,KAAK,UAAU,GAGnG,KAAK,OAAO,CACf,CAEA,SAAW,CACR,KAAK,qBAAqB,EAC1B,KAAK,qBAAuB,KAAK,UAAU,sBAAsB,EAAE,MACnE,KAAK,OAAO,CACf,CAMA,WAAa,CACV,OAAI,KAAK,cAAkB,KAAK,mBAAqB,EAAa,IAClE,KAAK,WAAa,KAAK,aAAe,EACtC,aAAc,KAAK,oBAAqB,EACxC,KAAK,qBAAuB,WAAY,IAAO,CAC5C,KAAK,cACR,EAAG,GAAI,EAEP,KAAK,OAAO,EACL,GACV,CAEA,WAAa,CACV,OAAI,KAAK,cAAgB,EAAW,IACpC,KAAK,WAAa,KAAK,aAAe,EACtC,aAAc,KAAK,oBAAqB,EACxC,KAAK,qBAAuB,WAAY,IAAO,CAC5C,KAAK,cACR,EAAG,GAAI,EAEP,KAAK,OAAO,EACL,GACV,CAMA,sBAAwB,CACrB,MAAMC,EAAc,OAAO,WACrBC,EAAc,KAAK,cAEzB,KAAK,iBAAiB,QAASC,GAAU,CAClCA,EAAQF,IAGR,CAAG,KAAK,YAAYE,CAAK,EAAE,cAAkB,IAE9C,KAAK,cAAkB,CAAC,KAAK,YAAYA,CAAK,EAAE,eAI/C,CAAG,KAAK,YAAYA,CAAK,EAAE,IAAQ,IAGpC,KAAK,IAAQ,CAAC,KAAK,YAAYA,CAAK,EAAE,IAAQ,GAEpD,CAAC,EAGG,KAAK,aAAe,GAAKD,IAAgB,KAAK,gBAC3C,KAAK,cAAgBA,EAOtB,KAAK,aAAiBA,EAAc,KAAK,aAAiB,KAAK,cACvD,KAAK,cAAgBA,IAM7B,KAAK,aAAe,KAAK,MAAO,KAAK,aAAe,KAAK,aAAc,IAI7E,KAAK,mBAAqB,KAAK,aAAe,KAAK,aACtD,CAEA,uBAAyB,CACtB,IAAIE,EAA4B,KAE5B,KAAK,cAAgB,IAEtBA,GAAe,KAAK,qBAAyB,KAAK,KAAQ,KAAK,cAAgB,IAAU,KAAK,eAGjG,KAAK,OAAO,QAAS,CAAEN,EAAO,IAAQ,CAC/BM,IAAcN,EAAM,MAAM,MAAQM,EAAa,MAI/CA,IAAe,OAEhBN,EAAM,MAAM,MAAQ,IAInB,IAAM,IAEVA,EAAM,MAAM,WAAa,KAAK,IAAM,KACvC,CAAC,CACJ,CAEA,QAAU,CACP,KAAK,cAAc,MAAM,mBAAqB,QAG9C,KAAK,cAAc,MAAM,UAAY,cAAc,EAAG,KAAK,YAAe,KAAK,qBAAuB,KAAK,WAC3G,KAAK,iBAAmB,GAExB,WAAY,IAAO,CAChB,KAAK,cAAc,MAAM,mBAAqB,EACjD,EAAG,GAAI,EAEP,WAAY,IAAO,CAChB,KAAK,iBAAmB,EAC3B,EAAG,GAAI,EAGP,KAAK,sBAAsB,EAG3B,KAAK,UAAY,GACjB,KAAK,eAAiB,GACtB,KAAK,wBAA0B,EAC/B,KAAK,YAAc,GACnB,KAAK,cAAgB,EACrB,KAAK,UAAY,EACjB,KAAK,sBAAwB,CAChC,CAGH,EAIC,IAAO,CAEL,IAAIO,EAAwC,KAI5C,SAAS,iBAAkB,cAAiB,GAAQ,CACjD,MAAMd,EAAS,EAAE,OAMjB,GALA,4BAA8B,mBAAoB,CAAE,EAKhDA,aAAkB,YAAe,CAClC,MAAMe,EAAgBf,EAAO,QAAS,uBAAwB,EAC1De,IAAkBD,IAAgBA,EAAeC,GAIxD,GAAI,CAACD,GAAgB,EAAGA,EAAa,qBAAqB,YAAe,CAACA,EAAa,UAAU,UAAa,CAC3GA,EAAe,KACf,OAIHA,EAAa,UAAU,aAAa,CACvC,CAAC,EAGD,SAASE,EAAa,EAAUC,EAAuB,GAAS,CAC7D,MAAMjB,EAAS,EAAE,OACbc,IAAiB,MAAQ,EAAGA,EAAa,qBAAqB,YAS9D,CAACG,GAAe,EAAGjB,aAAkB,aAAiBA,EAAO,QAAS,uBAAwB,IAAMc,KAExGA,EAAa,UAAU,cAAc,EACrCA,EAAe,KAClB,CAGA,SAAS,iBAAkB,YAAaE,CAAY,EACpD,SAAS,iBAAkB,aAAcA,CAAY,EAGrD,SAAS,iBAAkB,mBAAsB,GAAQ,CACtDA,EAAa,EAAG,EAAK,CACxB,CAAC,CAGJ,GAAG","sources":["webpack://js-components/webpack/bootstrap","webpack://js-components/webpack/runtime/define property getters","webpack://js-components/webpack/runtime/hasOwnProperty shorthand","webpack://js-components/./src/components/slider/slider.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import './slider.css';\r\n\r\n///resize observer for slider\r\nconst __JscSliderResizeObserver = new ResizeObserver( ( entries =>  {\r\n   entries.forEach( entry =>  {\r\n      const target = entry.target as JscSliderElement;\r\n      if( target.jscSlider instanceof JscSlider )  {\r\n         target.jscSlider._resize();\r\n      }\r\n   });\r\n}));\r\n\r\ninterface JscSliderElement extends HTMLElement  {\r\n   jscSlider?: JscSlider\r\n}\r\n\r\n///current pointer position\r\nlet __JscCurrentPointerPosition = 0;\r\n\r\ninterface JscSliderArgs {\r\n   container: string | HTMLElement,\r\n   slidesPerView?: number,\r\n   gap?: number,\r\n   prevEl?: string | HTMLElement,\r\n   nextEl?: string | HTMLElement,\r\n   breakPoints?: {},\r\n}\r\n\r\nfunction getPointerPosition( e: MouseEvent | TouchEvent )  {\r\n   return ( e instanceof MouseEvent ) ? e.clientX : e.touches[0].clientX;\r\n}\r\n\r\nexport default class JscSlider  {\r\n   ///core variables\r\n   container: JscSliderElement;\r\n   sliderWrapper: HTMLElement;\r\n   slides: NodeListOf<HTMLElement>;\r\n   sliderContainerWidth: number;\r\n\r\n   ///state variables\r\n   pointerStartingPosition = 0;\r\n   isClicked = false;\r\n   isPointerMoved = false;\r\n   currentIndex = 0;\r\n   slidesLength: number;\r\n   totalSlidesPerView: number;\r\n   firstDragTime = 0;\r\n   isFirstMove = false;\r\n   translate = 0;\r\n   breakPointWidths: number[] = [];\r\n   currentBreakPoint: number | null = null;\r\n   currentActiveWidth: number = 0;\r\n   _isTransitioning: boolean = false;\r\n   _transitionTimeoutId: ReturnType<typeof setTimeout>;\r\n   _tempIndex: number = 0;\r\n   _pointerPausePosition: number = 0;\r\n\r\n   ///can be change via args\r\n   slidesPerView = 1;\r\n   percentThreshold = 50;\r\n   timeThreshold = 300;\r\n   gap = 0;\r\n   breakPoints:any | {} = {};\r\n\r\n   constructor( args: JscSliderArgs )  {\r\n      ///check if container arg is string and valid DOM query\r\n      if( typeof args.container === 'string' )  {\r\n         args.container = document.querySelector( args.container ) as HTMLElement;\r\n      }\r\n\r\n      if( !( args.container instanceof HTMLElement ) )  return\r\n\r\n      this.container = args.container;\r\n      /** any expression after this */\r\n\r\n      /**** will improve this in more efficient way ****/\r\n      ///assign other arguments to global class variables\r\n\r\n      if( args.slidesPerView && args.slidesPerView > 0 )  {\r\n         this.slidesPerView = args.slidesPerView;\r\n      }\r\n\r\n      if( args.gap && args.gap > 0 )  this.gap = args.gap;\r\n\r\n      let prevBtn: string | HTMLElement | undefined = args.prevEl;\r\n      let nextBtn: string | HTMLElement | undefined = args.nextEl;\r\n\r\n      if( typeof prevBtn === 'string' )  {\r\n         prevBtn = this.container.querySelector( prevBtn ) ? this.container.querySelector( prevBtn ) as HTMLElement : document.querySelector( prevBtn ) as HTMLElement;\r\n      }\r\n\r\n      if( prevBtn instanceof HTMLElement )  {\r\n         prevBtn.setAttribute( 'aria-label', 'Previous slide' );\r\n         prevBtn.addEventListener( 'click', this.prevSlide.bind( this ) );\r\n      }\r\n\r\n      if( typeof nextBtn === 'string' )  {\r\n         nextBtn = this.container.querySelector( nextBtn ) ? this.container.querySelector( nextBtn ) as HTMLElement : document.querySelector( nextBtn ) as HTMLElement;\r\n      }\r\n\r\n      if( nextBtn instanceof HTMLElement )  {\r\n         nextBtn.setAttribute( 'aria-label', 'Next slide' );\r\n         nextBtn.addEventListener( 'click', this.nextSlide.bind( this ) );\r\n      }\r\n\r\n      if( typeof args.breakPoints === 'object' )  this.breakPoints = args.breakPoints;\r\n\r\n      /** ******* */\r\n\r\n      this._init();\r\n   }\r\n\r\n   _init()  {\r\n      ///save slider container width\r\n      this.sliderContainerWidth = this.container.getBoundingClientRect().width;\r\n      this.sliderWrapper = this.container.querySelector( '.jsc-slider-wrapper' ) as HTMLElement;\r\n      this.slides = this.container.querySelectorAll( '.slide' ) as NodeListOf<HTMLElement>;\r\n\r\n      if( !this.sliderWrapper || !this.slides )  return\r\n\r\n      ///this will be change when autoplay option going to introduce but for now it's hardcoded\r\n      this.sliderWrapper.setAttribute( 'aria-live', 'polite' );\r\n\r\n      ///https://developer.mozilla.org/en-US/docs/Glossary/Expando\r\n      ///add current instance to the container element for futher use likely for event bubbling\r\n      this.container.jscSlider = this;\r\n\r\n      /** initialize breakpoints */\r\n\r\n      ///save all the default values to breakpoint with value of width \"0\"\r\n      this.breakPoints[0] = {\r\n         slidesPerView: this.slidesPerView,\r\n         gap: this.gap\r\n      }\r\n\r\n      const breakPointWidths: number[] = [];\r\n      ///add all the breakpoints keys which has value of number to the breakPointWidths\r\n      Object.keys( this.breakPoints ).forEach( val => ( +val >= 0 ) ? breakPointWidths.push( +val ) : '' );\r\n      this.breakPointWidths = breakPointWidths.sort();\r\n\r\n      ///saving slides length\r\n      this.slidesLength = this.slides.length;\r\n\r\n      ///A11Y\r\n      this.slides.forEach( ( slide, i ) =>  {\r\n         slide.setAttribute( 'role', 'group' );\r\n         slide.setAttribute( 'aria-roledescription', 'slide' );\r\n         slide.setAttribute( 'aria-label', `${i + 1} / ${this.slidesLength}` );\r\n      });\r\n\r\n      ///apply all the responsive options to the slides\r\n      this._applyResponsiveness();\r\n\r\n      /** end initialization of breakpoints */\r\n\r\n      ///add all the slider events\r\n      this.container.addEventListener( 'pointerdown', this._pointerDown.bind( this ) );\r\n      this.container.addEventListener( 'pointerup', this._pointerLeave.bind( this ) );\r\n\r\n      ///add resize observer\r\n      __JscSliderResizeObserver.observe( this.container );\r\n\r\n      ///calculate slides dimensions\r\n      this._calcSlidesDimensions();\r\n   }\r\n\r\n   /** All Event functions */\r\n\r\n   _pointerDown( e: MouseEvent | TouchEvent )  {\r\n      const target = e.target as HTMLElement;\r\n\r\n      ///don't start moving slider if current target is not a slide, wrapper or container\r\n      if( target !== this.container && target.closest( '.slide' )?.closest( '.jsc-slider-container' ) !== this.container\r\n          && target.closest( '.jsc-slider-wrapper' ) !== this.sliderWrapper ) return\r\n\r\n      ///prevent default behavior in slide like image dragging effect inside slide\r\n      e.preventDefault();\r\n\r\n      this.pointerStartingPosition = getPointerPosition( e );\r\n      this.isClicked = true;\r\n\r\n      ///if slider is clicked during transitioning\r\n      if( this._isTransitioning )  {\r\n         clearTimeout( this._transitionTimeoutId );\r\n         this._isTransitioning = false;\r\n         this._tempIndex = this.currentIndex;\r\n         this.sliderWrapper.style.transitionDuration = '';\r\n         /**\r\n         * we need pointer pause position from the left\r\n         * so suppose if the current slide is first slide\r\n         * and when it's changing to next slide we will get\r\n         * the extact left position from \"getBoundingClientRect\" method\r\n         * but if the slide position is other than first we get the\r\n         * leftPosition + sliderWidth x currentSlidePosition = ?\r\n         * (actually it's not accurate but it's easy to understand this way)\r\n         * so we don't want \"sliderWidth x currentSlidePosition\" to be added to the\r\n         * leftPosition so we have reduce it according to the current slide\r\n         */\r\n         this._pointerPausePosition = ( ( this.currentIndex ) * ( this.sliderContainerWidth + this.gap ) ) + this.sliderWrapper.getBoundingClientRect().left;\r\n         this._pointerMove();\r\n      }\r\n   }\r\n\r\n   _pointerMove()  {\r\n      if( !this.isClicked ) return\r\n\r\n      if( !this.isFirstMove )  {\r\n         this.isFirstMove = true;\r\n         this.firstDragTime = new Date().getTime();\r\n      }\r\n\r\n      ///if positive then going to previous slide otherwise to the next slide\r\n      this.translate = ( __JscCurrentPointerPosition - this.pointerStartingPosition ) + ( this._pointerPausePosition );\r\n\r\n      ///slider width plus gap\r\n      const sliderWidthPlusGap = this.sliderContainerWidth + this.gap;\r\n\r\n      ///if current slide is last slide and going to next slide decrease the translate value\r\n      if( this.currentIndex >= ( this.totalSlidesPerView - 1 ) && this.translate < 0 )  {\r\n         this.sliderWrapper.style.transform = `translateX(${( this.translate / 2.5 ) - ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n         return\r\n      }\r\n\r\n      ///if current slide is first slide and going to previous slide decrease the translate value\r\n      if( this.currentIndex <= 0 && this.translate > 0 )  {\r\n         this.sliderWrapper.style.transform = `translateX(${( this.translate / 2.5 ) + ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n         return\r\n      }\r\n\r\n      ///move the slider\r\n      this.sliderWrapper.style.transform = `translateX(${this.translate - ( this.currentIndex * sliderWidthPlusGap )}px)`;\r\n   }\r\n\r\n   _pointerLeave()  {\r\n      ///if the slider was clicked without moving\r\n      ///then we don't have to do anything after that\r\n      if( !this.isFirstMove )  {\r\n         this.isClicked = false;\r\n         return\r\n      }\r\n\r\n      ///current percentage of drag\r\n      const currentDragPercent = ( 100 * Math.abs( this.translate ) ) / this.sliderContainerWidth;\r\n\r\n      ///if the drag distance is greater than percentThreshold of the container\r\n      ///or currentTime - dragStartTime is lower than the time threshold\r\n      ///increase or decrease the index based on the translate value\r\n      if( this.isClicked && ( ( new Date().getTime() - this.firstDragTime ) < this.timeThreshold || currentDragPercent > this.percentThreshold ) )  {\r\n\r\n         ///going to previous slide\r\n         if( this.translate > 0 && this.currentIndex > 0 )  this.prevSlide();\r\n\r\n         ///going to next slide\r\n         if( this.translate < 0 && this.currentIndex < ( this.totalSlidesPerView - 1 ) )  this.nextSlide();\r\n      }\r\n\r\n      this._reset();\r\n   }\r\n\r\n   _resize()  {\r\n      this._applyResponsiveness();\r\n      this.sliderContainerWidth = this.container.getBoundingClientRect().width;\r\n      this._reset();\r\n   }\r\n\r\n   /** End Event functions */\r\n\r\n   /** Controls Functions */\r\n\r\n   nextSlide()  {\r\n      if( this.currentIndex >= ( this.totalSlidesPerView - 1 ) ) return false;\r\n      this._tempIndex = this.currentIndex + 1;\r\n      clearTimeout( this._transitionTimeoutId );\r\n      this._transitionTimeoutId = setTimeout( () =>  {\r\n         this.currentIndex++;\r\n      }, 200 );\r\n\r\n      this._reset();\r\n      return true;\r\n   }\r\n\r\n   prevSlide()  {\r\n      if( this.currentIndex <= 0 ) return false;\r\n      this._tempIndex = this.currentIndex - 1;\r\n      clearTimeout( this._transitionTimeoutId );\r\n      this._transitionTimeoutId = setTimeout( () =>  {\r\n         this.currentIndex--;\r\n      }, 200 );\r\n\r\n      this._reset();\r\n      return true;\r\n   }\r\n\r\n   /** End Controls Functions */\r\n\r\n   /** Utilities Functions */\r\n\r\n   _applyResponsiveness()  {\r\n      const windowWidth = window.innerWidth;\r\n      const prevPerView = this.slidesPerView;\r\n\r\n      this.breakPointWidths.forEach( width =>  {\r\n         if( width > windowWidth )  return\r\n\r\n         ///slidesPerView\r\n         if( +( this.breakPoints[width].slidesPerView ) > 0 )  {\r\n            ///not trying to add values\r\n            this.slidesPerView = ( +this.breakPoints[width].slidesPerView );\r\n         }\r\n\r\n         ///gap\r\n         if( +( this.breakPoints[width].gap ) > 0 )  {\r\n            ///multiplying gap because i don't want \"1\" gap equal to \"1px\"\r\n            ///i want to double the gap\r\n            this.gap = ( +this.breakPoints[width].gap ) * 2;\r\n         }\r\n      });\r\n\r\n      ///adjust slide index based on current slidesPerView\r\n      if( this.currentIndex > 0 && prevPerView !== this.slidesPerView )  {\r\n         if( this.slidesPerView < prevPerView )  {\r\n            /**\r\n            * Suppose we have total of 6 slides and we want to find out the nearest index,\r\n            * so the current value of slidesPreView = 3 and the currentIndex = 1 (2nd slide)\r\n            * and we are changing slidesPreView to 1 so the currentIndex should be 3 (4th slide)\r\n            * prevSlidePreView x currentIndex = 3\r\n            */\r\n            this.currentIndex = ( prevPerView * this.currentIndex ) / this.slidesPerView;\r\n         } else if( this.slidesPerView > prevPerView )  {\r\n            /**\r\n            * prevView = 1, prevIndex = 4, currentView = 3\r\n            * prevIndex / currentView = 1.3333333\r\n            * round it to 1\r\n            */\r\n            this.currentIndex = Math.floor( this.currentIndex / this.slidesPerView );\r\n         }\r\n      }\r\n\r\n      this.totalSlidesPerView = this.slidesLength / this.slidesPerView;\r\n   }\r\n\r\n   _calcSlidesDimensions()  {\r\n      let slideWidth: number | null = null;\r\n\r\n      if( this.slidesPerView > 1 )  {\r\n         ///calculate slide width\r\n         slideWidth = ( this.sliderContainerWidth - ( this.gap * ( this.slidesPerView - 1 ) ) ) / this.slidesPerView;\r\n      }\r\n\r\n      this.slides.forEach( ( slide, i ) =>  {\r\n         if( slideWidth )  slide.style.width = slideWidth + 'px';\r\n\r\n         ///have to do this because the previous slidePerView slide width can be\r\n         ///different, so we have to remove the previous width it\r\n         if( slideWidth === null )  {\r\n            ///if slidePerView is 1 no need to add any width to slide\r\n            slide.style.width = '';\r\n         }\r\n\r\n         ///don't add left margin if this is first slide\r\n         if( i === 0 ) return\r\n\r\n         slide.style.marginLeft = this.gap + 'px';\r\n      });\r\n   }\r\n\r\n   _reset()  {\r\n      this.sliderWrapper.style.transitionDuration = \"300ms\";\r\n      ///restore slide position\r\n      ///using tempIndex for mimicking translate\r\n      this.sliderWrapper.style.transform = `translateX(${-( this._tempIndex * ( this.sliderContainerWidth + this.gap ) )}px)`;\r\n      this._isTransitioning = true;\r\n\r\n      setTimeout( () =>  {\r\n         this.sliderWrapper.style.transitionDuration = '';\r\n      }, 300 );\r\n\r\n      setTimeout( () =>  {\r\n         this._isTransitioning = false;\r\n      }, 200 );\r\n\r\n      ///recalculate slides width\r\n      this._calcSlidesDimensions();\r\n\r\n      ///reset state variables\r\n      this.isClicked = false;\r\n      this.isPointerMoved = false;\r\n      this.pointerStartingPosition = 0;\r\n      this.isFirstMove = false;\r\n      this.firstDragTime = 0;\r\n      this.translate = 0;\r\n      this._pointerPausePosition = 0;\r\n   }\r\n\r\n   /** End Utilities Functions */\r\n}\r\n\r\n\r\n///using IIFE so activeSlider variable can't be alter by anyone\r\n(() =>  {\r\n   ///current active slider\r\n   let activeSlider: null | JscSliderElement = null;\r\n\r\n   /** global events */\r\n\r\n   document.addEventListener( 'pointermove', ( e ) =>  {\r\n      const target = e.target;\r\n      __JscCurrentPointerPosition = getPointerPosition( e );\r\n\r\n      ///checking if the target is not a HTMLdocument because HTMLdocument don't have any nearset element\r\n      ///so there is no point of assigning new activeSlider, same goes to if the previous activeSlider\r\n      ///is equal to current target slider container\r\n      if( target instanceof HTMLElement )  {\r\n         const closestSlider = target.closest( '.jsc-slider-container' ) as JscSliderElement;\r\n         if( closestSlider !== activeSlider )  activeSlider = closestSlider;\r\n      }\r\n\r\n      ///if slider isClicked is false then don't move current activeSlider\r\n      if( !activeSlider || !( activeSlider.jscSlider instanceof JscSlider ) || !activeSlider.jscSlider.isClicked )  {\r\n         activeSlider = null\r\n         return\r\n      }\r\n\r\n      ///move slider\r\n      activeSlider.jscSlider._pointerMove();\r\n   });\r\n\r\n\r\n   function sliderLeave( e: Event, isBlurEvent: boolean = false )  {\r\n      const target = e.target;\r\n      if( activeSlider === null || !( activeSlider.jscSlider instanceof JscSlider ) ) return\r\n\r\n      /**\r\n      * if closest element is equal to current active slider don't need to reset the slider.\r\n      * Doing this because if the pointer pointing at the slider gap which is margin then this event\r\n      * will occur so which means slider is still moving so there is no need to rest the slider\r\n      * P.S don't need to worry about how slider will actually leave when the closest slider is activeSlider\r\n      * because it's directly implamented in the slider class itself\r\n      */\r\n      if( !isBlurEvent && !( target instanceof HTMLElement && ( target.closest( '.jsc-slider-container' ) !== activeSlider ) ) )  return\r\n\r\n      activeSlider.jscSlider._pointerLeave();\r\n      activeSlider = null;\r\n   }\r\n\r\n   ///pointer leave events\r\n   document.addEventListener( 'pointerup', sliderLeave );\r\n   document.addEventListener( 'pointerout', sliderLeave );\r\n\r\n   ///this event will happen when browser tab changes\r\n   document.addEventListener( 'visibilitychange', ( e ) =>  {\r\n      sliderLeave( e, true );\r\n   });\r\n\r\n   /** End global events */\r\n})();\r\n"],"names":["exports","definition","key","obj","prop","entries","entry","target","e","args","prevBtn","nextBtn","breakPointWidths","val","slide","sliderWidthPlusGap","currentDragPercent","windowWidth","prevPerView","width","slideWidth","activeSlider","closestSlider","sliderLeave","isBlurEvent"],"sourceRoot":""}